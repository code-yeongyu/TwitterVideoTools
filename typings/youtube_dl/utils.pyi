"""
This type stub file was generated by pyright.
"""

import platform
import sys
from .compat import compat_HTMLParser, compat_cookiejar, compat_urllib_request

def register_socks_protocols(): # -> None:
    ...

compiled_regex_type = ...
def random_user_agent(): # -> LiteralString:
    ...

std_headers = ...
USER_AGENTS = ...
NO_DEFAULT = ...
ENGLISH_MONTH_NAMES = ...
MONTH_NAMES = ...
KNOWN_EXTENSIONS = ...
ACCENT_CHARS = ...
DATE_FORMATS = ...
DATE_FORMATS_DAY_FIRST = ...
DATE_FORMATS_MONTH_FIRST = ...
PACKED_CODES_RE = ...
JSON_LD_RE = ...
def preferredencoding(): # -> str:
    """Get preferred encoding.

    Returns the best encoding scheme for the system, based on
    locale.getpreferredencoding() and some further tweaks.
    """
    ...

def write_json_file(obj, fn): # -> None:
    """ Encode obj as JSON and write it to fn, atomically if possible """
    ...

if sys.version_info >= (2, 7):
    def find_xpath_attr(node, xpath, key, val=...):
        """ Find the xpath xpath[@key=val] """
        ...
    
else:
    ...
def xpath_with_ns(path, ns_map): # -> LiteralString:
    ...

def xpath_element(node, xpath, name=..., fatal=..., default=...): # -> object | None:
    ...

def xpath_text(node, xpath, name=..., fatal=..., default=...): # -> object | None:
    ...

def xpath_attr(node, xpath, key, name=..., fatal=..., default=...): # -> object | None:
    ...

def get_element_by_id(id, html): # -> None:
    """Return the content of the tag with the specified ID in the passed HTML document"""
    ...

def get_element_by_class(class_name, html): # -> None:
    """Return the content of the first tag with the specified class in the passed HTML document"""
    ...

def get_element_by_attribute(attribute, value, html, escape_value=...): # -> None:
    ...

def get_elements_by_class(class_name, html): # -> list[Unknown]:
    """Return the content of all tags with the specified class in the passed HTML document as a list"""
    ...

def get_elements_by_attribute(attribute, value, html, escape_value=...): # -> list[Unknown]:
    """Return the content of the tag with the specified attribute in the passed HTML document"""
    ...

class HTMLAttributeParser(compat_HTMLParser):
    """Trivial HTML parser to gather the attributes for a single element"""
    def __init__(self) -> None:
        ...
    
    def handle_starttag(self, tag, attrs): # -> None:
        ...
    


def extract_attributes(html_element): # -> dict[str, str | None]:
    """Given a string for an HTML element such as
    <el
         a="foo" B="bar" c="&98;az" d=boz
         empty= noval entity="&amp;"
         sq='"' dq="'"
    >
    Decode and return a dictionary of attributes.
    {
        'a': 'foo', 'b': 'bar', c: 'baz', d: 'boz',
        'empty': '', 'noval': None, 'entity': '&',
        'sq': '"', 'dq': '\''
    }.
    NB HTMLParser is stricter in Python 2.6 & 3.2 than in later versions,
    but the cases in the unit test will work for all of 2.6, 2.7, 3.2-3.5.
    """
    ...

def clean_html(html): # -> str:
    """Clean an HTML snippet into a readable string"""
    ...

def sanitize_open(filename, open_mode): # -> tuple[BinaryIO | TextIO, Unknown] | tuple[TextIOWrapper, Unknown]:
    """Try to open the given filename, and slightly tweak it if this fails.

    Attempts to open the given filename. If this fails, it tries to change
    the filename slightly, step by step, until it's either able to open it
    or it fails and raises a final exception, like the standard open()
    function.

    It returns the tuple (stream, definitive_file_name).
    """
    ...

def timeconvert(timestr): # -> int | None:
    """Convert RFC 2822 defined time string into system timestamp"""
    ...

def sanitize_filename(s, restricted=..., is_id=...): # -> str:
    """Sanitizes a string so it could be used as part of a filename.
    If restricted is set, use a stricter subset of allowed characters.
    Set is_id if this is not an arbitrary string, but an ID that should be kept
    if possible.
    """
    ...

def sanitize_path(s):
    """Sanitizes and normalizes path on Windows"""
    ...

def sanitize_url(url): # -> str:
    ...

def sanitized_Request(url, *args, **kwargs): # -> Request:
    ...

def expand_path(s):
    """Expand shell variables and ~"""
    ...

def orderedSet(iterable): # -> list[Unknown]:
    """ Remove all duplicates from the input iterable """
    ...

def unescapeHTML(s): # -> str | None:
    ...

def get_subprocess_encoding(): # -> str:
    ...

def encodeFilename(s, for_subprocess=...):
    """
    @param s The name of the file
    """
    ...

def decodeFilename(b, for_subprocess=...):
    ...

def encodeArgument(s):
    ...

def decodeArgument(b):
    ...

def decodeOption(optval): # -> str:
    ...

def formatSeconds(secs): # -> LiteralString:
    ...

def make_HTTPS_handler(params, **kwargs): # -> YoutubeDLHTTPSHandler:
    ...

def bug_reports_message(): # -> LiteralString:
    ...

class YoutubeDLError(Exception):
    """Base exception for YoutubeDL errors."""
    ...


class ExtractorError(YoutubeDLError):
    """Error during info extraction."""
    def __init__(self, msg, tb=..., expected=..., cause=..., video_id=...) -> None:
        """ tb, if given, is the original traceback (so that it can be printed out).
        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.
        """
        ...
    
    def format_traceback(self): # -> str | None:
        ...
    


class UnsupportedError(ExtractorError):
    def __init__(self, url) -> None:
        ...
    


class RegexNotFoundError(ExtractorError):
    """Error when a regex didn't match"""
    ...


class GeoRestrictedError(ExtractorError):
    """Geographic restriction Error exception.

    This exception may be thrown when a video is not available from your
    geographic location due to geographic restrictions imposed by a website.
    """
    def __init__(self, msg, countries=...) -> None:
        ...
    


class DownloadError(YoutubeDLError):
    """Download Error exception.

    This exception may be thrown by FileDownloader objects if they are not
    configured to continue on errors. They will contain the appropriate
    error message.
    """
    def __init__(self, msg, exc_info=...) -> None:
        """ exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). """
        ...
    


class SameFileError(YoutubeDLError):
    """Same File exception.

    This exception will be thrown by FileDownloader objects if they detect
    multiple files would have to be downloaded to the same file on disk.
    """
    ...


class PostProcessingError(YoutubeDLError):
    """Post Processing exception.

    This exception may be raised by PostProcessor's .run() method to
    indicate an error in the postprocessing task.
    """
    def __init__(self, msg) -> None:
        ...
    


class MaxDownloadsReached(YoutubeDLError):
    """ --max-downloads limit has been reached. """
    ...


class UnavailableVideoError(YoutubeDLError):
    """Unavailable Format exception.

    This exception will be thrown when a video is requested
    in a format that is not available for that video.
    """
    ...


class ContentTooShortError(YoutubeDLError):
    """Content Too Short exception.

    This exception may be raised by FileDownloader objects when a file they
    download is too small for what the server announced first, indicating
    the connection was probably interrupted.
    """
    def __init__(self, downloaded, expected) -> None:
        ...
    


class XAttrMetadataError(YoutubeDLError):
    def __init__(self, code=..., msg=...) -> None:
        ...
    


class XAttrUnavailableError(YoutubeDLError):
    ...


def handle_youtubedl_headers(headers): # -> dict[Unknown, Unknown]:
    ...

class YoutubeDLHandler(compat_urllib_request.HTTPHandler):
    """Handler for HTTP requests and responses.

    This class, when installed with an OpenerDirector, automatically adds
    the standard headers to every HTTP request and handles gzipped and
    deflated responses from web servers. If compression is to be avoided in
    a particular request, the original request in the program code only has
    to include the HTTP header "Youtubedl-no-compression", which will be
    removed before making the real request.

    Part of this code was copied from:

    http://techknack.net/python-urllib2-handlers/

    Andrew Rowls, the author of that code, agreed to release it to the
    public domain.
    """
    def __init__(self, params, *args, **kwargs) -> None:
        ...
    
    def http_open(self, req): # -> HTTPResponse:
        ...
    
    @staticmethod
    def deflate(data): # -> bytes:
        ...
    
    def http_request(self, req): # -> HEADRequest | PUTRequest | Request:
        ...
    
    def http_response(self, req, resp):
        ...
    
    https_request = ...
    https_response = ...


def make_socks_conn_class(base_class, socks_proxy): # -> Type[SocksConnection]:
    class SocksConnection(base_class):
        ...
    
    

class YoutubeDLHTTPSHandler(compat_urllib_request.HTTPSHandler):
    def __init__(self, params, https_conn_class=..., *args, **kwargs) -> None:
        ...
    
    def https_open(self, req): # -> HTTPResponse:
        ...
    


class YoutubeDLCookieJar(compat_cookiejar.MozillaCookieJar):
    """
    See [1] for cookie file format.

    1. https://curl.haxx.se/docs/http-cookies.html
    """
    _HTTPONLY_PREFIX = ...
    _ENTRY_LEN = ...
    _HEADER = ...
    _CookieFileEntry = ...
    def save(self, filename=..., ignore_discard=..., ignore_expires=...): # -> None:
        """
        Save cookies to a file.

        Most of the code is taken from CPython 3.8 and slightly adapted
        to support cookie files with UTF-8 in both python 2 and 3.
        """
        ...
    
    def load(self, filename=..., ignore_discard=..., ignore_expires=...): # -> None:
        """Load cookies from a file."""
        ...
    


class YoutubeDLCookieProcessor(compat_urllib_request.HTTPCookieProcessor):
    def __init__(self, cookiejar=...) -> None:
        ...
    
    def http_response(self, request, response): # -> HTTPResponse:
        ...
    
    https_request = ...
    https_response = ...


class YoutubeDLRedirectHandler(compat_urllib_request.HTTPRedirectHandler):
    """YoutubeDL redirect handler

    The code is based on HTTPRedirectHandler implementation from CPython [1].

    This redirect handler solves two issues:
     - ensures redirect URL is always unicode under python 2
     - introduces support for experimental HTTP response status code
       308 Permanent Redirect [2] used by some sites [3]

    1. https://github.com/python/cpython/blob/master/Lib/urllib/request.py
    2. https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308
    3. https://github.com/ytdl-org/youtube-dl/issues/28768
    """
    http_error_301 = ...
    def redirect_request(self, req, fp, code, msg, headers, newurl): # -> Request:
        """Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """
        ...
    


def extract_timezone(date_str): # -> tuple[timedelta, Unknown]:
    ...

def parse_iso8601(date_str, delimiter=..., timezone=...): # -> int | None:
    """ Return a UNIX timestamp from the given date """
    ...

def date_formats(day_first=...): # -> list[Literal['%d %B %Y', '%d %b %Y', '%B %d %Y', '%B %dst %Y', '%B %dnd %Y', '%B %drd %Y', '%B %dth %Y', '%b %d %Y', '%b %dst %Y', '%b %dnd %Y', '%b %drd %Y', '%b %dth %Y', '%b %dst %Y %I:%M', '%b %dnd %Y %I:%M', '%b %drd %Y %I:%M', '%b %dth %Y %I:%M', '%Y %m %d', '%Y-%m-%d', '%Y/%m/%d', '%Y/%m/%d %H:%M', '%Y/%m/%d %H:%M:%S', '%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%d.%m.%Y %H:%M', '%d.%m.%Y %H.%M', '%Y-%m-%dT%H:%M:%SZ', '%Y-%m-%dT%H:%M:%S.%fZ', '%Y-%m-%dT%H:%M:%S.%f0Z', '%Y-%m-%dT%H:%M:%S', '%Y-%m-%dT%H:%M:%S.%f', '%Y-%m-%dT%H:%M', '%b %d %Y at %H:%M', '%b %d %Y at %H:%M:%S', '%B %d %Y at %H:%M', '%B %d %Y at %H:%M:%S']]:
    ...

def unified_strdate(date_str, day_first=...): # -> None:
    """Return a string with the date in the format YYYYMMDD"""
    ...

def unified_timestamp(date_str, day_first=...): # -> int | None:
    ...

def determine_ext(url, default_ext=...): # -> str:
    ...

def subtitles_filename(filename, sub_lang, sub_format, expected_real_ext=...): # -> LiteralString:
    ...

def date_from_str(date_str): # -> date:
    """
    Return a datetime object from a string in the format YYYYMMDD or
    (now|today)[+-][0-9](day|week|month|year)(s)?"""
    ...

def hyphenate_date(date_str): # -> str:
    """
    Convert a date in 'YYYYMMDD' format to 'YYYY-MM-DD' format"""
    ...

class DateRange:
    """Represents a time interval between two dates"""
    def __init__(self, start=..., end=...) -> None:
        """start and end must be strings in the format accepted by date"""
        ...
    
    @classmethod
    def day(cls, day): # -> Self@DateRange:
        """Returns a range that only contains the given day"""
        ...
    
    def __contains__(self, date): # -> bool:
        """Check if the date is in the range"""
        ...
    
    def __str__(self) -> str:
        ...
    


def platform_name(): # -> str:
    """ Returns the platform name as a compat_str """
    ...

def write_string(s, out=..., encoding=...): # -> None:
    ...

def bytes_to_intlist(bs): # -> list[Unknown] | list[int]:
    ...

def intlist_to_bytes(xs): # -> bytes:
    ...

if sys.platform == 'win32':
    ...
else:
    ...
class locked_file:
    def __init__(self, filename, mode, encoding=...) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, etype, value, traceback):
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def write(self, *args): # -> int:
        ...
    
    def read(self, *args): # -> str:
        ...
    


def get_filesystem_encoding(): # -> str:
    ...

def shell_quote(args): # -> LiteralString:
    ...

def smuggle_url(url, data):
    """ Pass additional data in a URL for internal use. """
    ...

def unsmuggle_url(smug_url, default=...): # -> tuple[Unknown, Unknown | None] | tuple[Unknown, Any]:
    ...

def format_bytes(bytes): # -> str:
    ...

def lookup_unit_table(unit_table, s): # -> int | None:
    ...

def parse_filesize(s): # -> int | None:
    ...

def parse_count(s): # -> int | None:
    ...

def parse_resolution(s): # -> dict[str, int]:
    ...

def parse_bitrate(s): # -> int | None:
    ...

def month_by_name(name, lang=...): # -> int | None:
    """ Return the number of a month by (locale-independently) English name """
    ...

def month_by_abbreviation(abbrev): # -> int | None:
    """ Return the number of a month by (locale-independently) English
        abbreviations """
    ...

def fix_xml_ampersands(xml_str): # -> str:
    """Replace all the '&' by '&amp;' in XML"""
    ...

def setproctitle(title): # -> None:
    ...

def remove_start(s, start):
    ...

def remove_end(s, end):
    ...

def remove_quotes(s):
    ...

def url_basename(url): # -> str:
    ...

def base_url(url): # -> str:
    ...

def urljoin(base, path): # -> str | None:
    ...

class HEADRequest(compat_urllib_request.Request):
    def get_method(self): # -> Literal['HEAD']:
        ...
    


class PUTRequest(compat_urllib_request.Request):
    def get_method(self): # -> Literal['PUT']:
        ...
    


def int_or_none(v, scale=..., default=..., get_attr=..., invscale=...): # -> int | None:
    ...

def str_or_none(v, default=...): # -> None:
    ...

def str_to_int(int_str): # -> int | None:
    """ A more relaxed version of int_or_none """
    ...

def float_or_none(v, scale=..., invscale=..., default=...): # -> float | None:
    ...

def bool_or_none(v, default=...): # -> bool | None:
    ...

def strip_or_none(v, default=...): # -> None:
    ...

def url_or_none(url): # -> None:
    ...

def parse_duration(s): # -> float | Literal[0] | None:
    ...

def prepend_extension(filename, ext, expected_real_ext=...): # -> LiteralString:
    ...

def replace_extension(filename, ext, expected_real_ext=...): # -> LiteralString:
    ...

def check_executable(exe, args=...): # -> Literal[False]:
    """ Checks if the given binary is installed somewhere in PATH, and returns its name.
    args can be a list of arguments for a short output (like -version) """
    ...

def get_exe_version(exe, args=..., version_re=..., unrecognized=...): # -> str | Any | Literal[False]:
    """ Returns the version of the specified executable,
    or False if the executable is not present """
    ...

def detect_exe_version(output, version_re=..., unrecognized=...): # -> str | Any:
    ...

class PagedList:
    def __len__(self): # -> int:
        ...
    


class OnDemandPagedList(PagedList):
    def __init__(self, pagefunc, pagesize, use_cache=...) -> None:
        ...
    
    def getslice(self, start=..., end=...): # -> list[Unknown]:
        ...
    


class InAdvancePagedList(PagedList):
    def __init__(self, pagefunc, pagecount, pagesize) -> None:
        ...
    
    def getslice(self, start=..., end=...): # -> list[Unknown]:
        ...
    


def uppercase_escape(s): # -> str:
    ...

def lowercase_escape(s): # -> str:
    ...

def escape_rfc3986(s):
    """Escape non-ASCII characters as suggested by RFC 3986"""
    ...

def escape_url(url): # -> str:
    """Escape URL as suggested by RFC 3986"""
    ...

def read_batch_urls(batch_fd): # -> list[Unknown | bool]:
    ...

def urlencode_postdata(*args, **kargs): # -> bytes:
    ...

def update_url_query(url, query): # -> str:
    ...

def update_Request(req, url=..., data=..., headers=..., query=...): # -> HEADRequest | PUTRequest | Request:
    ...

def multipart_encode(data, boundary=...): # -> tuple[Unknown | bytes, str | Unknown]:
    '''
    Encode a dict to RFC 7578-compliant form-data

    data:
        A dict where keys and values can be either Unicode or bytes-like
        objects.
    boundary:
        If specified a Unicode object, it's used as the boundary. Otherwise
        a random boundary is generated.

    Reference: https://tools.ietf.org/html/rfc7578
    '''
    ...

def dict_get(d, key_or_keys, default=..., skip_false_values=...): # -> None:
    ...

def try_get(src, getter, expected_type=...): # -> None:
    ...

def merge_dicts(*dicts): # -> dict[Unknown, Unknown]:
    ...

def encode_compat_str(string, encoding=..., errors=...):
    ...

US_RATINGS = ...
TV_PARENTAL_GUIDELINES = ...
def parse_age_limit(s): # -> int | None:
    ...

def strip_jsonp(code): # -> str:
    ...

def js_to_json(code): # -> str:
    ...

def qualities(quality_ids): # -> (qid: Unknown) -> (Unknown | Literal[-1]):
    """ Get a numeric quality value out of a list of possible values """
    ...

DEFAULT_OUTTMPL = ...
def limit_length(s, length): # -> None:
    """ Add ellipses to overly long strings """
    ...

def version_tuple(v): # -> tuple[int, ...]:
    ...

def is_outdated_version(version, limit, assume_new=...): # -> bool:
    ...

def ytdl_is_updateable(): # -> bool:
    """ Returns if youtube-dl can be updated with -U """
    ...

def args_to_str(args): # -> LiteralString:
    ...

def error_to_compat_str(err): # -> str:
    ...

def mimetype2ext(mt): # -> str | None:
    ...

def parse_codecs(codecs_str): # -> dict[str, Any] | dict[str, Any | str]:
    ...

def urlhandle_detect_ext(url_handle): # -> str | Any | None:
    ...

def encode_data_uri(data, mime_type): # -> str:
    ...

def age_restricted(content_limit, age_limit): # -> Literal[False]:
    """ Returns True iff the content should be blocked """
    ...

def is_html(first_bytes): # -> Match[str] | None:
    """ Detect whether a file contains HTML by examining its first bytes. """
    ...

def determine_protocol(info_dict): # -> str:
    ...

def render_table(header_row, data): # -> LiteralString:
    """ Render a list of rows, each as a list of values """
    ...

def match_str(filter_str, dct): # -> bool:
    """ Filter a dictionary with a simple string syntax. Returns True (=passes filter) or false """
    ...

def match_filter_func(filter_str): # -> (info_dict: Unknown) -> (LiteralString | None):
    ...

def parse_dfxp_time_expr(time_expr): # -> float | None:
    ...

def srt_subtitles_timecode(seconds): # -> LiteralString:
    ...

def dfxp2srt(dfxp_data): # -> LiteralString:
    '''
    @param dfxp_data A bytes-like object containing DFXP data
    @returns A unicode object containing converted SRT data
    '''
    class TTMLPElementParser:
        ...
    
    

def cli_option(params, command_option, param): # -> list[Unknown]:
    ...

def cli_bool_option(params, command_option, param, true_value=..., false_value=..., separator=...): # -> list[Unknown] | list[Unknown | str]:
    ...

def cli_valueless_option(params, command_option, param, expected_value=...): # -> list[Unknown]:
    ...

def cli_configuration_args(params, param, default=...): # -> list[Unknown]:
    ...

class ISO639Utils:
    _lang_map = ...
    @classmethod
    def short2long(cls, code): # -> str | None:
        """Convert language code from ISO 639-1 to ISO 639-2/T"""
        ...
    
    @classmethod
    def long2short(cls, code): # -> str | None:
        """Convert language code from ISO 639-2/T to ISO 639-1"""
        ...
    


class ISO3166Utils:
    _country_map = ...
    @classmethod
    def short2full(cls, code): # -> str | None:
        """Convert an ISO 3166-2 country code to the corresponding full name"""
        ...
    


class GeoUtils:
    _country_ip_map = ...
    @classmethod
    def random_ipv4(cls, code_or_block): # -> None:
        ...
    


class PerRequestProxyHandler(compat_urllib_request.ProxyHandler):
    def __init__(self, proxies=...) -> None:
        ...
    
    def proxy_open(self, req, proxy, type): # -> _UrlopenRet | None:
        ...
    


def long_to_bytes(n, blocksize=...): # -> bytes:
    """long_to_bytes(n:long, blocksize:int) : string
    Convert a long integer to a byte string.

    If optional blocksize is given and greater than zero, pad the front of the
    byte string with binary zeros so that the length is a multiple of
    blocksize.
    """
    ...

def bytes_to_long(s): # -> Any | Literal[0]:
    """bytes_to_long(string) : long
    Convert a byte string to a long integer.

    This is (essentially) the inverse of long_to_bytes().
    """
    ...

def ohdave_rsa_encrypt(data, exponent, modulus): # -> str:
    '''
    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/

    Input:
        data: data to encrypt, bytes-like object
        exponent, modulus: parameter e and N of RSA algorithm, both integer
    Output: hex string of encrypted data

    Limitation: supports one block encryption only
    '''
    ...

def pkcs1pad(data, length):
    """
    Padding input data with PKCS#1 scheme

    @param {int[]} data        input data
    @param {int}   length      target length
    @returns {int[]}           padded data
    """
    ...

def encode_base_n(num, n, table=...): # -> str:
    ...

def decode_packed_codes(code): # -> str:
    ...

def caesar(s, alphabet, shift): # -> LiteralString:
    ...

def rot47(s): # -> LiteralString:
    ...

def parse_m3u8_attributes(attrib): # -> dict[Unknown, Unknown]:
    ...

def urshift(val, n):
    ...

def decode_png(png_data): # -> tuple[Any, Any, list[Unknown]]:
    ...

def write_xattr(path, key, value): # -> None:
    ...

def random_birthday(year_field, month_field, day_field): # -> dict[Unknown, str]:
    ...

def clean_podcast_url(url): # -> str:
    ...

