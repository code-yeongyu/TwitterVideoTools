"""
This type stub file was generated by pyright.
"""

from .common import PostProcessor
from ..compat import functools
from ..utils import MEDIA_EXTENSIONS, PostProcessingError

EXT_TO_OUT_FORMATS = ...
ACODECS = ...
def create_mapping_re(supported): # -> Pattern[str]:
    ...

def resolve_mapping(source, mapping): # -> tuple[Unknown, str] | tuple[Unknown, None] | tuple[None, str]:
    """
    Get corresponding item from a mapping string like 'A>B/C>D/E'
    @returns    (target, error_message)
    """
    ...

class FFmpegPostProcessorError(PostProcessingError):
    ...


class FFmpegPostProcessor(PostProcessor):
    _ffmpeg_location = ...
    def __init__(self, downloader=...) -> None:
        ...
    
    @staticmethod
    def get_versions_and_features(downloader=...): # -> tuple[dict[cached_property | Any, cached_property | Any], dict[Unknown, Unknown]]:
        ...
    
    @staticmethod
    def get_versions(downloader=...): # -> dict[cached_property | Any, cached_property | Any]:
        ...
    
    _ffmpeg_to_avconv = ...
    @functools.cached_property
    def basename(self): # -> cached_property | Any:
        ...
    
    @functools.cached_property
    def probe_basename(self): # -> cached_property | Any:
        ...
    
    @property
    def available(self): # -> bool:
        ...
    
    @property
    def executable(self): # -> str | None:
        ...
    
    @property
    def probe_available(self): # -> bool:
        ...
    
    @property
    def probe_executable(self): # -> str | None:
        ...
    
    @staticmethod
    def stream_copy_opts(copy=..., *, ext=...): # -> Generator[Literal['-map', '0', '-dn', '-ignore_unknown', '-c', 'copy', '-c:s', 'mov_text'], None, None]:
        ...
    
    def check_version(self): # -> None:
        ...
    
    def get_audio_codec(self, path):
        ...
    
    def get_metadata_object(self, path, opts=...): # -> Any:
        ...
    
    def get_stream_number(self, path, keys, value): # -> tuple[int | None, int]:
        ...
    
    def run_ffmpeg_multiple_files(self, input_paths, out_path, opts, **kwargs): # -> Literal['', b'']:
        ...
    
    def real_run_ffmpeg(self, input_path_opts, output_path_opts, *, expected_retcodes=...): # -> Literal['', b'']:
        ...
    
    def run_ffmpeg(self, path, out_path, opts, **kwargs): # -> Literal['', b'']:
        ...
    
    def force_keyframes(self, filename, timestamps): # -> str:
        ...
    
    def concat_files(self, in_files, out_file, concat_opts=...): # -> None:
        """
        Use concat demuxer to concatenate multiple files having identical streams.

        Only inpoint, outpoint, and duration concat options are supported.
        See https://ffmpeg.org/ffmpeg-formats.html#concat-1 for details
        """
        ...
    


class FFmpegExtractAudioPP(FFmpegPostProcessor):
    COMMON_AUDIO_EXTS = MEDIA_EXTENSIONS.common_audio + ('wma', )
    SUPPORTED_EXTS = ...
    FORMAT_RE = ...
    def __init__(self, downloader=..., preferredcodec=..., preferredquality=..., nopostoverwrites=...) -> None:
        ...
    
    def run_ffmpeg(self, path, out_path, codec, more_opts): # -> None:
        ...
    
    @PostProcessor._restrict_to(images=False)
    def run(self, information): # -> tuple[list[Unknown], Unknown] | tuple[list[str | Unknown], Unknown]:
        ...
    


class FFmpegVideoConvertorPP(FFmpegPostProcessor):
    SUPPORTED_EXTS = ...
    FORMAT_RE = ...
    _ACTION = ...
    def __init__(self, downloader=..., preferedformat=...) -> None:
        ...
    
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegVideoRemuxerPP(FFmpegVideoConvertorPP):
    _ACTION = ...


class FFmpegEmbedSubtitlePP(FFmpegPostProcessor):
    SUPPORTED_EXTS = ...
    def __init__(self, downloader=..., already_have_subtitle=...) -> None:
        ...
    
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegMetadataPP(FFmpegPostProcessor):
    def __init__(self, downloader, add_metadata=..., add_chapters=..., add_infojson=...) -> None:
        ...
    
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegMergerPP(FFmpegPostProcessor):
    SUPPORTED_EXTS = MEDIA_EXTENSIONS.common_video
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[Unknown, Unknown]:
        ...
    
    def can_merge(self): # -> bool:
        ...
    


class FFmpegFixupPostProcessor(FFmpegPostProcessor):
    ...


class FFmpegFixupStretchedPP(FFmpegFixupPostProcessor):
    @PostProcessor._restrict_to(images=False, audio=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegFixupM4aPP(FFmpegFixupPostProcessor):
    @PostProcessor._restrict_to(images=False, video=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegFixupM3u8PP(FFmpegFixupPostProcessor):
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegFixupTimestampPP(FFmpegFixupPostProcessor):
    def __init__(self, downloader=..., trim=...) -> None:
        ...
    
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegCopyStreamPP(FFmpegFixupPostProcessor):
    MESSAGE = ...
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegFixupDurationPP(FFmpegCopyStreamPP):
    MESSAGE = ...


class FFmpegFixupDuplicateMoovPP(FFmpegCopyStreamPP):
    MESSAGE = ...


class FFmpegSubtitlesConvertorPP(FFmpegPostProcessor):
    SUPPORTED_EXTS = MEDIA_EXTENSIONS.subtitles
    def __init__(self, downloader=..., format=...) -> None:
        ...
    
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegSplitChaptersPP(FFmpegPostProcessor):
    def __init__(self, downloader, force_keyframes=...) -> None:
        ...
    
    @PostProcessor._restrict_to(images=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegThumbnailsConvertorPP(FFmpegPostProcessor):
    SUPPORTED_EXTS = MEDIA_EXTENSIONS.thumbnails
    FORMAT_RE = ...
    def __init__(self, downloader=..., format=...) -> None:
        ...
    
    @classmethod
    def is_webp(cls, path): # -> bool:
        ...
    
    def fixup_webp(self, info, idx=...): # -> None:
        ...
    
    def convert_thumbnail(self, thumbnail_filename, target_ext): # -> LiteralString:
        ...
    
    def run(self, info): # -> tuple[list[Unknown], Unknown]:
        ...
    


class FFmpegConcatPP(FFmpegPostProcessor):
    def __init__(self, downloader, only_multi_video=...) -> None:
        ...
    
    def concat_files(self, in_files, out_file): # -> list[Unknown] | None:
        ...
    
    @PostProcessor._restrict_to(images=False, simulated=False)
    def run(self, info): # -> tuple[list[Unknown], Unknown] | tuple[Unknown | list[Unknown] | object | None, Unknown]:
        ...
    


