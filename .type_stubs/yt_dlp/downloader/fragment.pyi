"""
This type stub file was generated by pyright.
"""

import concurrent.futures
from .common import FileDownloader
from .http import HttpFD

class HttpQuietDownloader(HttpFD):
    def to_screen(self, *args, **kargs): # -> None:
        ...
    
    to_console_title = ...


class FragmentFD(FileDownloader):
    """
    A base file downloader class for fragmented media (e.g. f4m/m3u8 manifests).

    Available options:

    fragment_retries:   Number of times to retry a fragment for HTTP error (DASH
                        and hlsnative only)
    skip_unavailable_fragments:
                        Skip unavailable fragments (DASH and hlsnative only)
    keep_fragments:     Keep downloaded fragments on disk after downloading is
                        finished
    concurrent_fragment_downloads:  The number of threads to use for native hls and dash downloads
    _no_ytdl_file:      Don't use .ytdl file

    For each incomplete fragment download yt-dlp keeps on disk a special
    bookkeeping file with download state and metadata (in future such files will
    be used for any incomplete download handled by yt-dlp). This file is
    used to properly handle resuming, check download file consistency and detect
    potential errors. The file has a .ytdl extension and represents a standard
    JSON file of the following format:

    extractor:
        Dictionary of extractor related data. TBD.

    downloader:
        Dictionary of downloader related data. May contain following data:
            current_fragment:
                Dictionary with current (being downloaded) fragment data:
                index:  0-based index of current fragment among all fragments
            fragment_count:
                Total count of fragments

    This feature is experimental and file format may change in future.
    """
    def report_retry_fragment(self, err, frag_index, count, retries): # -> None:
        ...
    
    def report_skip_fragment(self, frag_index, err=...): # -> None:
        ...
    
    def decrypter(self, info_dict): # -> (fragment: Unknown, frag_content: Unknown) -> (Unknown | bytes | None):
        ...
    
    def download_and_append_fragments_multiple(self, *args, **kwargs): # -> bool:
        '''
        @params (ctx1, fragments1, info_dict1), (ctx2, fragments2, info_dict2), ...
                all args must be either tuple or list
        '''
        class FTPE(concurrent.futures.ThreadPoolExecutor):
            ...
        
        
    
    def download_and_append_fragments(self, ctx, fragments, info_dict, *, is_fatal=..., pack_func=..., finish_func=..., tpe=..., interrupt_trigger=...): # -> bool:
        ...
    


