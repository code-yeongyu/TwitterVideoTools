"""
This type stub file was generated by pyright.
"""

import collections
import collections.abc
import contextlib
import html.parser
import http.cookiejar
import json
import platform
import ssl
import subprocess
import sys
import types
import urllib.request
import ctypes
from .compat import functools
from .dependencies import brotli

def register_socks_protocols(): # -> None:
    ...

compiled_regex_type = ...
def random_user_agent(): # -> LiteralString:
    ...

SUPPORTED_ENCODINGS = ...
if brotli:
    ...
std_headers = ...
USER_AGENTS = ...
NO_DEFAULT = ...
IDENTITY = ...
ENGLISH_MONTH_NAMES = ...
MONTH_NAMES = ...
TIMEZONE_NAMES = ...
ACCENT_CHARS = ...
DATE_FORMATS = ...
DATE_FORMATS_DAY_FIRST = ...
DATE_FORMATS_MONTH_FIRST = ...
PACKED_CODES_RE = ...
JSON_LD_RE = ...
NUMBER_RE = ...
@functools.cache
def preferredencoding(): # -> str:
    """Get preferred encoding.

    Returns the best encoding scheme for the system, based on
    locale.getpreferredencoding() and some further tweaks.
    """
    ...

def write_json_file(obj, fn): # -> None:
    """ Encode obj as JSON and write it to fn, atomically if possible """
    ...

def find_xpath_attr(node, xpath, key, val=...):
    """ Find the xpath xpath[@key=val] """
    ...

def xpath_with_ns(path, ns_map): # -> LiteralString:
    ...

def xpath_element(node, xpath, name=..., fatal=..., default=...): # -> object | None:
    ...

def xpath_text(node, xpath, name=..., fatal=..., default=...): # -> object | None:
    ...

def xpath_attr(node, xpath, key, name=..., fatal=..., default=...): # -> object | None:
    ...

def get_element_by_id(id, html, **kwargs): # -> str | None:
    """Return the content of the tag with the specified ID in the passed HTML document"""
    ...

def get_element_html_by_id(id, html, **kwargs): # -> None:
    """Return the html of the tag with the specified ID in the passed HTML document"""
    ...

def get_element_by_class(class_name, html): # -> str | None:
    """Return the content of the first tag with the specified class in the passed HTML document"""
    ...

def get_element_html_by_class(class_name, html): # -> None:
    """Return the html of the first tag with the specified class in the passed HTML document"""
    ...

def get_element_by_attribute(attribute, value, html, **kwargs): # -> str | None:
    ...

def get_element_html_by_attribute(attribute, value, html, **kargs): # -> None:
    ...

def get_elements_by_class(class_name, html, **kargs): # -> list[str | None]:
    """Return the content of all tags with the specified class in the passed HTML document as a list"""
    ...

def get_elements_html_by_class(class_name, html): # -> list[Unknown]:
    """Return the html of all tags with the specified class in the passed HTML document as a list"""
    ...

def get_elements_by_attribute(*args, **kwargs): # -> list[str | None]:
    """Return the content of the tag with the specified attribute in the passed HTML document"""
    ...

def get_elements_html_by_attribute(*args, **kwargs): # -> list[Unknown]:
    """Return the html of the tag with the specified attribute in the passed HTML document"""
    ...

def get_elements_text_and_html_by_attribute(attribute, value, html, *, tag=..., escape_value=...): # -> Generator[tuple[str | None, Unknown], None, None]:
    """
    Return the text (content) and the html (whole) of the tag with the specified
    attribute in the passed HTML document
    """
    ...

class HTMLBreakOnClosingTagParser(html.parser.HTMLParser):
    """
    HTML parser which raises HTMLBreakOnClosingTagException upon reaching the
    closing tag for the first opening tag it has encountered, and can be used
    as a context manager
    """
    class HTMLBreakOnClosingTagException(Exception):
        ...
    
    
    def __init__(self) -> None:
        ...
    
    def __enter__(self): # -> Self@HTMLBreakOnClosingTagParser:
        ...
    
    def __exit__(self, *_): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def handle_starttag(self, tag, _): # -> None:
        ...
    
    def handle_endtag(self, tag): # -> None:
        ...
    


def get_element_text_and_html_by_tag(tag, html): # -> tuple[Unknown, Unknown]:
    """
    For the first element with the specified tag in the passed HTML document
    return its' content (text) and the whole element (html)
    """
    ...

class HTMLAttributeParser(html.parser.HTMLParser):
    """Trivial HTML parser to gather the attributes for a single element"""
    def __init__(self) -> None:
        ...
    
    def handle_starttag(self, tag, attrs):
        ...
    


class HTMLListAttrsParser(html.parser.HTMLParser):
    """HTML parser to gather the attributes for the elements of a list"""
    def __init__(self) -> None:
        ...
    
    def handle_starttag(self, tag, attrs): # -> None:
        ...
    
    def handle_endtag(self, tag): # -> None:
        ...
    


def extract_attributes(html_element): # -> dict[str, str | None]:
    """Given a string for an HTML element such as
    <el
         a="foo" B="bar" c="&98;az" d=boz
         empty= noval entity="&amp;"
         sq='"' dq="'"
    >
    Decode and return a dictionary of attributes.
    {
        'a': 'foo', 'b': 'bar', c: 'baz', d: 'boz',
        'empty': '', 'noval': None, 'entity': '&',
        'sq': '"', 'dq': '\''
    }.
    """
    ...

def parse_list(webpage): # -> list[Unknown]:
    """Given a string for an series of HTML <li> elements,
    return a dictionary of their attributes"""
    ...

def clean_html(html): # -> str:
    """Clean an HTML snippet into a readable string"""
    ...

class LenientJSONDecoder(json.JSONDecoder):
    def __init__(self, *args, transform_source=..., ignore_extra=..., **kwargs) -> None:
        ...
    
    def decode(self, s): # -> Any:
        ...
    


def sanitize_open(filename, open_mode): # -> tuple[BinaryIO | TextIO, Unknown] | tuple[TextIOWrapper, Unknown | str] | None:
    """Try to open the given filename, and slightly tweak it if this fails.

    Attempts to open the given filename. If this fails, it tries to change
    the filename slightly, step by step, until it's either able to open it
    or it fails and raises a final exception, like the standard open()
    function.

    It returns the tuple (stream, definitive_file_name).
    """
    ...

def timeconvert(timestr): # -> int | None:
    """Convert RFC 2822 defined time string into system timestamp"""
    ...

def sanitize_filename(s, restricted=..., is_id=...): # -> str:
    """Sanitizes a string so it could be used as part of a filename.
    @param restricted   Use a stricter subset of allowed characters
    @param is_id        Whether this is an ID that should be kept unchanged if possible.
                        If unset, yt-dlp's new sanitization rules are in effect
    """
    ...

def sanitize_path(s, force=...): # -> str:
    """Sanitizes and normalizes path on Windows"""
    ...

def sanitize_url(url, *, scheme=...): # -> str | None:
    ...

def extract_basic_auth(url): # -> tuple[Unknown, None] | tuple[str, str]:
    ...

def sanitized_Request(url, *args, **kwargs): # -> Request:
    ...

def expand_path(s):
    """Expand shell variables and ~"""
    ...

def orderedSet(iterable, *, lazy=...): # -> Generator[Unknown, None, None] | list[Unknown]:
    """Remove all duplicates from the input iterable"""
    ...

def unescapeHTML(s): # -> str | None:
    ...

def escapeHTML(text):
    ...

def process_communicate_or_kill(p, *args, **kwargs): # -> tuple[Unknown, Unknown]:
    ...

class Popen(subprocess.Popen):
    if sys.platform == 'win32':
        _startupinfo = ...
    else:
        _startupinfo = ...
    def __init__(self, *args, env=..., text=..., **kwargs) -> None:
        ...
    
    def communicate_or_kill(self, *args, **kwargs): # -> tuple[Unknown, Unknown]:
        ...
    
    def kill(self, *, timeout=...): # -> None:
        ...
    
    @classmethod
    def run(cls, *args, timeout=..., **kwargs): # -> tuple[Unknown | Literal['', b''], Unknown | Literal['', b''], int | Any]:
        ...
    


def get_subprocess_encoding(): # -> str:
    ...

def encodeFilename(s, for_subprocess=...): # -> str:
    ...

def decodeFilename(b, for_subprocess=...):
    ...

def encodeArgument(s): # -> str:
    ...

def decodeArgument(b):
    ...

def decodeOption(optval): # -> str:
    ...

_timetuple = ...
def timetuple_from_msec(msec): # -> Time:
    ...

def formatSeconds(secs, delim=..., msec=...): # -> str:
    ...

def make_HTTPS_handler(params, **kwargs): # -> YoutubeDLHTTPSHandler:
    ...

def bug_reports_message(before=...): # -> str:
    ...

class YoutubeDLError(Exception):
    """Base exception for YoutubeDL errors."""
    msg = ...
    def __init__(self, msg=...) -> None:
        ...
    


network_exceptions = ...
if hasattr(ssl, 'CertificateError'):
    ...
network_exceptions = ...
class ExtractorError(YoutubeDLError):
    """Error during info extraction."""
    def __init__(self, msg, tb=..., expected=..., cause=..., video_id=..., ie=...) -> None:
        """ tb, if given, is the original traceback (so that it can be printed out).
        If expected is set, this is a normal error message and most likely not a bug in yt-dlp.
        """
        ...
    
    def format_traceback(self): # -> str | None:
        ...
    


class UnsupportedError(ExtractorError):
    def __init__(self, url) -> None:
        ...
    


class RegexNotFoundError(ExtractorError):
    """Error when a regex didn't match"""
    ...


class GeoRestrictedError(ExtractorError):
    """Geographic restriction Error exception.

    This exception may be thrown when a video is not available from your
    geographic location due to geographic restrictions imposed by a website.
    """
    def __init__(self, msg, countries=..., **kwargs) -> None:
        ...
    


class UserNotLive(ExtractorError):
    """Error when a channel/user is not live"""
    def __init__(self, msg=..., **kwargs) -> None:
        ...
    


class DownloadError(YoutubeDLError):
    """Download Error exception.

    This exception may be thrown by FileDownloader objects if they are not
    configured to continue on errors. They will contain the appropriate
    error message.
    """
    def __init__(self, msg, exc_info=...) -> None:
        """ exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). """
        ...
    


class EntryNotInPlaylist(YoutubeDLError):
    """Entry not in playlist exception.

    This exception will be thrown by YoutubeDL when a requested entry
    is not found in the playlist info_dict
    """
    msg = ...


class SameFileError(YoutubeDLError):
    """Same File exception.

    This exception will be thrown by FileDownloader objects if they detect
    multiple files would have to be downloaded to the same file on disk.
    """
    msg = ...
    def __init__(self, filename=...) -> None:
        ...
    


class PostProcessingError(YoutubeDLError):
    """Post Processing exception.

    This exception may be raised by PostProcessor's .run() method to
    indicate an error in the postprocessing task.
    """
    ...


class DownloadCancelled(YoutubeDLError):
    """ Exception raised when the download queue should be interrupted """
    msg = ...


class ExistingVideoReached(DownloadCancelled):
    """ --break-on-existing triggered """
    msg = ...


class RejectedVideoReached(DownloadCancelled):
    """ --break-on-reject triggered """
    msg = ...


class MaxDownloadsReached(DownloadCancelled):
    """ --max-downloads limit has been reached. """
    msg = ...


class ReExtractInfo(YoutubeDLError):
    """ Video info needs to be re-extracted. """
    def __init__(self, msg, expected=...) -> None:
        ...
    


class ThrottledDownload(ReExtractInfo):
    """ Download speed below --throttled-rate. """
    msg = ...
    def __init__(self) -> None:
        ...
    


class UnavailableVideoError(YoutubeDLError):
    """Unavailable Format exception.

    This exception will be thrown when a video is requested
    in a format that is not available for that video.
    """
    msg = ...
    def __init__(self, err=...) -> None:
        ...
    


class ContentTooShortError(YoutubeDLError):
    """Content Too Short exception.

    This exception may be raised by FileDownloader objects when a file they
    download is too small for what the server announced first, indicating
    the connection was probably interrupted.
    """
    def __init__(self, downloaded, expected) -> None:
        ...
    


class XAttrMetadataError(YoutubeDLError):
    def __init__(self, code=..., msg=...) -> None:
        ...
    


class XAttrUnavailableError(YoutubeDLError):
    ...


def handle_youtubedl_headers(headers): # -> dict[Unknown, Unknown]:
    ...

class YoutubeDLHandler(urllib.request.HTTPHandler):
    """Handler for HTTP requests and responses.

    This class, when installed with an OpenerDirector, automatically adds
    the standard headers to every HTTP request and handles gzipped and
    deflated responses from web servers. If compression is to be avoided in
    a particular request, the original request in the program code only has
    to include the HTTP header "Youtubedl-no-compression", which will be
    removed before making the real request.

    Part of this code was copied from:

    http://techknack.net/python-urllib2-handlers/

    Andrew Rowls, the author of that code, agreed to release it to the
    public domain.
    """
    def __init__(self, params, *args, **kwargs) -> None:
        ...
    
    def http_open(self, req): # -> HTTPResponse:
        ...
    
    @staticmethod
    def deflate(data): # -> bytes:
        ...
    
    @staticmethod
    def brotli(data):
        ...
    
    def http_request(self, req): # -> Request:
        ...
    
    def http_response(self, req, resp):
        ...
    
    https_request = ...
    https_response = ...


def make_socks_conn_class(base_class, socks_proxy): # -> Type[SocksConnection]:
    class SocksConnection(base_class):
        ...
    
    

class YoutubeDLHTTPSHandler(urllib.request.HTTPSHandler):
    def __init__(self, params, https_conn_class=..., *args, **kwargs) -> None:
        ...
    
    def https_open(self, req): # -> HTTPResponse:
        ...
    


def is_path_like(f): # -> bool:
    ...

class YoutubeDLCookieJar(http.cookiejar.MozillaCookieJar):
    """
    See [1] for cookie file format.

    1. https://curl.haxx.se/docs/http-cookies.html
    """
    _HTTPONLY_PREFIX = ...
    _ENTRY_LEN = ...
    _HEADER = ...
    _CookieFileEntry = ...
    def __init__(self, filename=..., *args, **kwargs) -> None:
        ...
    
    @contextlib.contextmanager
    def open(self, file, *, write=...): # -> Generator[TextIOWrapper | Unknown, None, None]:
        ...
    
    def save(self, filename=..., *args, **kwargs): # -> None:
        """
        Save cookies to a file.
        Code is taken from CPython 3.6
        https://github.com/python/cpython/blob/8d999cbf4adea053be6dbb612b9844635c4dfb8e/Lib/http/cookiejar.py#L2091-L2117 """
        ...
    
    def load(self, filename=..., ignore_discard=..., ignore_expires=...): # -> None:
        """Load cookies from a file."""
        ...
    


class YoutubeDLCookieProcessor(urllib.request.HTTPCookieProcessor):
    def __init__(self, cookiejar=...) -> None:
        ...
    
    def http_response(self, request, response): # -> HTTPResponse:
        ...
    
    https_request = ...
    https_response = ...


class YoutubeDLRedirectHandler(urllib.request.HTTPRedirectHandler):
    """YoutubeDL redirect handler

    The code is based on HTTPRedirectHandler implementation from CPython [1].

    This redirect handler solves two issues:
     - ensures redirect URL is always unicode under python 2
     - introduces support for experimental HTTP response status code
       308 Permanent Redirect [2] used by some sites [3]

    1. https://github.com/python/cpython/blob/master/Lib/urllib/request.py
    2. https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308
    3. https://github.com/ytdl-org/youtube-dl/issues/28768
    """
    http_error_301 = ...
    def redirect_request(self, req, fp, code, msg, headers, newurl): # -> Request:
        """Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """
        ...
    


def extract_timezone(date_str): # -> tuple[timedelta, Unknown]:
    ...

def parse_iso8601(date_str, delimiter=..., timezone=...): # -> int | None:
    """ Return a UNIX timestamp from the given date """
    ...

def date_formats(day_first=...): # -> list[Literal['%d %B %Y', '%d %b %Y', '%B %d %Y', '%B %dst %Y', '%B %dnd %Y', '%B %drd %Y', '%B %dth %Y', '%b %d %Y', '%b %dst %Y', '%b %dnd %Y', '%b %drd %Y', '%b %dth %Y', '%b %dst %Y %I:%M', '%b %dnd %Y %I:%M', '%b %drd %Y %I:%M', '%b %dth %Y %I:%M', '%Y %m %d', '%Y-%m-%d', '%Y.%m.%d.', '%Y/%m/%d', '%Y/%m/%d %H:%M', '%Y/%m/%d %H:%M:%S', '%Y%m%d%H%M', '%Y%m%d%H%M%S', '%Y%m%d', '%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M:%S:%f', '%d.%m.%Y %H:%M', '%d.%m.%Y %H.%M', '%Y-%m-%dT%H:%M:%SZ', '%Y-%m-%dT%H:%M:%S.%fZ', '%Y-%m-%dT%H:%M:%S.%f0Z', '%Y-%m-%dT%H:%M:%S', '%Y-%m-%dT%H:%M:%S.%f', '%Y-%m-%dT%H:%M', '%b %d %Y at %H:%M', '%b %d %Y at %H:%M:%S', '%B %d %Y at %H:%M', '%B %d %Y at %H:%M:%S', '%H:%M %d-%b-%Y']]:
    ...

def unified_strdate(date_str, day_first=...): # -> str | None:
    """Return a string with the date in the format YYYYMMDD"""
    ...

def unified_timestamp(date_str, day_first=...): # -> int | float | None:
    ...

def determine_ext(url, default_ext=...): # -> str:
    ...

def subtitles_filename(filename, sub_lang, sub_format, expected_real_ext=...): # -> LiteralString:
    ...

def datetime_from_str(date_str, precision=..., format=...): # -> datetime:
    r"""
    Return a datetime object from a string.
    Supported format:
        (now|today|yesterday|DATE)([+-]\d+(microsecond|second|minute|hour|day|week|month|year)s?)?

    @param format       strftime format of DATE
    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day
                        auto: round to the unit provided in date_str (if applicable).
    """
    ...

def date_from_str(date_str, format=..., strict=...): # -> _Date:
    r"""
    Return a date object from a string using datetime_from_str

    @param strict  Restrict allowed patterns to "YYYYMMDD" and
                   (now|today|yesterday)(-\d+(day|week|month|year)s?)?
    """
    ...

def datetime_add_months(dt, months):
    """Increment/Decrement a datetime object by months."""
    ...

def datetime_round(dt, precision=...): # -> datetime:
    """
    Round a datetime object's time to a specific precision
    """
    ...

def hyphenate_date(date_str): # -> str:
    """
    Convert a date in 'YYYYMMDD' format to 'YYYY-MM-DD' format"""
    ...

class DateRange:
    """Represents a time interval between two dates"""
    def __init__(self, start=..., end=...) -> None:
        """start and end must be strings in the format accepted by date"""
        ...
    
    @classmethod
    def day(cls, day): # -> Self@DateRange:
        """Returns a range that only contains the given day"""
        ...
    
    def __contains__(self, date): # -> bool:
        """Check if the date is in the range"""
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


def platform_name(): # -> str:
    """ Returns the platform name as a str """
    ...

@functools.cache
def system_identifier(): # -> str:
    ...

@functools.cache
def get_windows_version(): # -> tuple[int, ...] | tuple[()]:
    ''' Get Windows version. returns () if it's not running on Windows '''
    ...

def write_string(s, out=..., encoding=...): # -> None:
    ...

def deprecation_warning(msg, *, printer=..., stacklevel=..., **kwargs): # -> None:
    ...

def bytes_to_intlist(bs): # -> list[Unknown] | list[int]:
    ...

def intlist_to_bytes(xs): # -> bytes:
    ...

class LockingUnsupportedError(OSError):
    msg = ...
    def __init__(self) -> None:
        ...
    


if sys.platform == 'win32':
    class OVERLAPPED(ctypes.Structure):
        _fields_ = ...
    
    
    kernel32 = ...
    LockFileEx = ...
    UnlockFileEx = ...
    whole_low = ...
    whole_high = ...
else:
    ...
class locked_file:
    locked = ...
    def __init__(self, filename, mode, block=..., encoding=...) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def unlock(self): # -> None:
        ...
    
    def __exit__(self, *_): # -> None:
        ...
    
    open = ...
    close = ...
    def __getattr__(self, attr): # -> Any:
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    


@functools.cache
def get_filesystem_encoding(): # -> str:
    ...

def shell_quote(args): # -> LiteralString:
    ...

def smuggle_url(url, data):
    """ Pass additional data in a URL for internal use. """
    ...

def unsmuggle_url(smug_url, default=...): # -> tuple[Unknown, Unknown | None] | tuple[Unknown, Any]:
    ...

def format_decimal_suffix(num, fmt=..., *, factor=...): # -> str | None:
    """ Formats numbers with decimal sufixes like K, M, etc """
    ...

def format_bytes(bytes): # -> str:
    ...

def lookup_unit_table(unit_table, s): # -> int | None:
    ...

def parse_filesize(s): # -> int | None:
    ...

def parse_count(s): # -> int | None:
    ...

def parse_resolution(s, *, lenient=...): # -> dict[str, int]:
    ...

def parse_bitrate(s): # -> int | None:
    ...

def month_by_name(name, lang=...): # -> int | None:
    """ Return the number of a month by (locale-independently) English name """
    ...

def month_by_abbreviation(abbrev): # -> int | None:
    """ Return the number of a month by (locale-independently) English
        abbreviations """
    ...

def fix_xml_ampersands(xml_str): # -> str:
    """Replace all the '&' by '&amp;' in XML"""
    ...

def setproctitle(title): # -> None:
    ...

def remove_start(s, start):
    ...

def remove_end(s, end):
    ...

def remove_quotes(s):
    ...

def get_domain(url): # -> str | None:
    """
    This implementation is inconsistent, but is kept for compatibility.
    Use this only for "webpage_url_domain"
    """
    ...

def url_basename(url): # -> str:
    ...

def base_url(url): # -> str:
    ...

def urljoin(base, path): # -> str | None:
    ...

class HEADRequest(urllib.request.Request):
    def get_method(self): # -> Literal['HEAD']:
        ...
    


class PUTRequest(urllib.request.Request):
    def get_method(self): # -> Literal['PUT']:
        ...
    


def int_or_none(v, scale=..., default=..., get_attr=..., invscale=...): # -> int | None:
    ...

def str_or_none(v, default=...): # -> str | None:
    ...

def str_to_int(int_str): # -> int | None:
    """ A more relaxed version of int_or_none """
    ...

def float_or_none(v, scale=..., invscale=..., default=...): # -> float | None:
    ...

def bool_or_none(v, default=...): # -> bool | None:
    ...

def strip_or_none(v, default=...): # -> str | None:
    ...

def url_or_none(url): # -> str | None:
    ...

def request_to_url(req): # -> str:
    ...

def strftime_or_none(timestamp, date_format, default=...): # -> str | None:
    ...

def parse_duration(s): # -> float | Literal[0] | None:
    ...

def prepend_extension(filename, ext, expected_real_ext=...): # -> str:
    ...

def replace_extension(filename, ext, expected_real_ext=...): # -> LiteralString:
    ...

def check_executable(exe, args=...): # -> Literal[False]:
    """ Checks if the given binary is installed somewhere in PATH, and returns its name.
    args can be a list of arguments for a short output (like -version) """
    ...

def detect_exe_version(output, version_re=..., unrecognized=...): # -> str | Any:
    ...

def get_exe_version(exe, args=..., version_re=..., unrecognized=...): # -> str | Any | Literal[False]:
    """ Returns the version of the specified executable,
    or False if the executable is not present """
    ...

def frange(start=..., stop=..., step=...): # -> Generator[int, None, None]:
    """Float range"""
    ...

class LazyList(collections.abc.Sequence):
    """Lazy immutable list from an iterable
    Note that slices of a LazyList are lists and not LazyList"""
    class IndexError(IndexError):
        ...
    
    
    def __init__(self, iterable, *, reverse=..., _cache=...) -> None:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    def exhaust(self): # -> list[Unknown]:
        """Evaluate the entire iterable"""
        ...
    
    def __getitem__(self, idx):
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __reversed__(self): # -> Self@LazyList:
        ...
    
    def __copy__(self): # -> Self@LazyList:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class PagedList:
    class IndexError(IndexError):
        ...
    
    
    def __len__(self): # -> int:
        ...
    
    def __init__(self, pagefunc, pagesize, use_cache=...) -> None:
        ...
    
    def getpage(self, pagenum): # -> list[Unknown]:
        ...
    
    def getslice(self, start=..., end=...): # -> list[Unknown]:
        ...
    
    def __getitem__(self, idx):
        ...
    


class OnDemandPagedList(PagedList):
    """Download pages until a page with less than maximum results"""
    ...


class InAdvancePagedList(PagedList):
    """PagedList with total number of pages known in advance"""
    def __init__(self, pagefunc, pagecount, pagesize) -> None:
        ...
    


class PlaylistEntries:
    MissingEntry = ...
    is_exhausted = ...
    def __init__(self, ydl, info_dict) -> None:
        ...
    
    PLAYLIST_ITEMS_RE = ...
    @classmethod
    def parse_playlist_items(cls, string): # -> Generator[slice | int, None, None]:
        ...
    
    def get_requested_items(self): # -> Generator[tuple[int, Unknown | Any], None, None]:
        ...
    
    def get_full_count(self): # -> int | Unknown | None:
        ...
    
    def __getitem__(self, idx): # -> Generator[tuple[int, Unknown | Any], None, None]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    class IndexError(IndexError):
        ...
    
    


def uppercase_escape(s): # -> str:
    ...

def lowercase_escape(s): # -> str:
    ...

def escape_rfc3986(s): # -> str:
    """Escape non-ASCII characters as suggested by RFC 3986"""
    ...

def escape_url(url): # -> str:
    """Escape URL as suggested by RFC 3986"""
    ...

def parse_qs(url, **kwargs): # -> dict[str, list[str]]:
    ...

def read_batch_urls(batch_fd): # -> list[str | Any | bool]:
    ...

def urlencode_postdata(*args, **kargs): # -> bytes:
    ...

def update_url_query(url, query): # -> str:
    ...

def update_Request(req, url=..., data=..., headers=..., query=...): # -> HEADRequest | PUTRequest | Request:
    ...

def multipart_encode(data, boundary=...): # -> tuple[bytes | Unknown, str | Unknown]:
    '''
    Encode a dict to RFC 7578-compliant form-data

    data:
        A dict where keys and values can be either Unicode or bytes-like
        objects.
    boundary:
        If specified a Unicode object, it's used as the boundary. Otherwise
        a random boundary is generated.

    Reference: https://tools.ietf.org/html/rfc7578
    '''
    ...

def variadic(x, allowed_types=...): # -> Iterable[Unknown] | tuple[Unknown | Iterable[Unknown]]:
    ...

def dict_get(d, key_or_keys, default=..., skip_false_values=...): # -> None:
    ...

def try_call(*funcs, expected_type=..., args=..., kwargs=...): # -> None:
    ...

def try_get(src, getter, expected_type=...): # -> None:
    ...

def filter_dict(dct, cndn=...): # -> dict[Unknown, Unknown]:
    ...

def merge_dicts(*dicts): # -> dict[Unknown, Unknown]:
    ...

def encode_compat_str(string, encoding=..., errors=...): # -> str:
    ...

US_RATINGS = ...
TV_PARENTAL_GUIDELINES = ...
def parse_age_limit(s): # -> int | None:
    ...

def strip_jsonp(code): # -> str:
    ...

def js_to_json(code, vars=..., *, strict=...): # -> str:
    ...

def qualities(quality_ids): # -> (qid: Unknown) -> (Unknown | Literal[-1]):
    """ Get a numeric quality value out of a list of possible values """
    ...

POSTPROCESS_WHEN = ...
DEFAULT_OUTTMPL = ...
OUTTMPL_TYPES = ...
STR_FORMAT_RE_TMPL = ...
STR_FORMAT_TYPES = ...
def limit_length(s, length): # -> None:
    """ Add ellipses to overly long strings """
    ...

def version_tuple(v): # -> tuple[int, ...]:
    ...

def is_outdated_version(version, limit, assume_new=...): # -> bool:
    ...

def ytdl_is_updateable(): # -> bool:
    """ Returns if yt-dlp can be updated with -U """
    ...

def args_to_str(args): # -> LiteralString:
    ...

def error_to_compat_str(err): # -> str:
    ...

def error_to_str(err): # -> str:
    ...

def mimetype2ext(mt): # -> str | None:
    ...

def ext2mimetype(ext_or_url): # -> str | None:
    ...

def parse_codecs(codecs_str): # -> dict[str, Any | str | None] | dict[str, Any]:
    ...

def get_compatible_ext(*, vcodecs, acodecs, vexts, aexts, preferences=...): # -> str:
    ...

def urlhandle_detect_ext(url_handle): # -> str | Any | None:
    ...

def encode_data_uri(data, mime_type): # -> str:
    ...

def age_restricted(content_limit, age_limit): # -> Literal[False]:
    """ Returns True iff the content should be blocked """
    ...

BOMS = ...
def is_html(first_bytes): # -> Match[str] | None:
    """ Detect whether a file contains HTML by examining its first bytes. """
    ...

def determine_protocol(info_dict): # -> bytes | str:
    ...

def render_table(header_row, data, delim=..., extra_gap=..., hide_empty=...): # -> LiteralString:
    """ Render a list of rows, each as a list of values.
    Text after a \t will be right aligned """
    ...

def match_str(filter_str, dct, incomplete=...): # -> bool:
    """ Filter a dictionary with a simple string syntax.
    @returns           Whether the filter passes
    @param incomplete  Set of keys that is expected to be missing from dct.
                       Can be True/False to indicate all/none of the keys may be missing.
                       All conditions on incomplete keys pass if the key is missing
    """
    ...

def match_filter_func(filters): # -> ((info_dict: Unknown, incomplete: bool = False) -> (object | str | None)) | None:
    ...

class download_range_func:
    def __init__(self, chapters, ranges) -> None:
        ...
    
    def __call__(self, info_dict, ydl): # -> Generator[dict[str, int] | dict[str, Unknown | Any], None, None]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


def parse_dfxp_time_expr(time_expr): # -> float | None:
    ...

def srt_subtitles_timecode(seconds): # -> LiteralString:
    ...

def ass_subtitles_timecode(seconds): # -> LiteralString:
    ...

def dfxp2srt(dfxp_data): # -> LiteralString:
    '''
    @param dfxp_data A bytes-like object containing DFXP data
    @returns A unicode object containing converted SRT data
    '''
    class TTMLPElementParser:
        ...
    
    

def cli_option(params, command_option, param, separator=...): # -> list[Unknown | str] | list[str]:
    ...

def cli_bool_option(params, command_option, param, true_value=..., false_value=..., separator=...): # -> list[Unknown | str] | list[str]:
    ...

def cli_valueless_option(params, command_option, param, expected_value=...): # -> list[Unknown]:
    ...

def cli_configuration_args(argdict, keys, default=..., use_compat=...): # -> list[Unknown] | tuple[Unknown, ...]:
    ...

class ISO639Utils:
    _lang_map = ...
    @classmethod
    def short2long(cls, code): # -> str | None:
        """Convert language code from ISO 639-1 to ISO 639-2/T"""
        ...
    
    @classmethod
    def long2short(cls, code): # -> str | None:
        """Convert language code from ISO 639-2/T to ISO 639-1"""
        ...
    


class ISO3166Utils:
    _country_map = ...
    @classmethod
    def short2full(cls, code): # -> str | None:
        """Convert an ISO 3166-2 country code to the corresponding full name"""
        ...
    


class GeoUtils:
    _country_ip_map = ...
    @classmethod
    def random_ipv4(cls, code_or_block): # -> str | None:
        ...
    


class PerRequestProxyHandler(urllib.request.ProxyHandler):
    def __init__(self, proxies=...) -> None:
        ...
    
    def proxy_open(self, req, proxy, type): # -> _UrlopenRet | None:
        ...
    


def long_to_bytes(n, blocksize=...): # -> bytes:
    """long_to_bytes(n:long, blocksize:int) : string
    Convert a long integer to a byte string.

    If optional blocksize is given and greater than zero, pad the front of the
    byte string with binary zeros so that the length is a multiple of
    blocksize.
    """
    ...

def bytes_to_long(s): # -> Any | Literal[0]:
    """bytes_to_long(string) : long
    Convert a byte string to a long integer.

    This is (essentially) the inverse of long_to_bytes().
    """
    ...

def ohdave_rsa_encrypt(data, exponent, modulus): # -> str:
    '''
    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/

    Input:
        data: data to encrypt, bytes-like object
        exponent, modulus: parameter e and N of RSA algorithm, both integer
    Output: hex string of encrypted data

    Limitation: supports one block encryption only
    '''
    ...

def pkcs1pad(data, length):
    """
    Padding input data with PKCS#1 scheme

    @param {int[]} data        input data
    @param {int}   length      target length
    @returns {int[]}           padded data
    """
    ...

def encode_base_n(num, n=..., table=...): # -> str:
    """Convert given int to a base-n string"""
    ...

def decode_base_n(string, n=..., table=...): # -> int:
    """Convert given base-n string to int"""
    ...

def decode_base(value, digits): # -> int:
    ...

def decode_packed_codes(code): # -> str:
    ...

def caesar(s, alphabet, shift): # -> LiteralString:
    ...

def rot47(s): # -> LiteralString:
    ...

def parse_m3u8_attributes(attrib): # -> dict[Unknown, Unknown]:
    ...

def urshift(val, n):
    ...

def decode_png(png_data): # -> tuple[Any, Any, list[Unknown]]:
    ...

def write_xattr(path, key, value): # -> None:
    ...

def random_birthday(year_field, month_field, day_field): # -> dict[Unknown, str]:
    ...

DOT_URL_LINK_TEMPLATE = ...
DOT_WEBLOC_LINK_TEMPLATE = ...
DOT_DESKTOP_LINK_TEMPLATE = ...
LINK_TEMPLATES = ...
def iri_to_uri(iri): # -> str:
    """
    Converts an IRI (Internationalized Resource Identifier, allowing Unicode characters) to a URI (Uniform Resource Identifier, ASCII-only).

    The function doesn't add an additional layer of escaping; e.g., it doesn't escape `%3C` as `%253C`. Instead, it percent-escapes characters with an underlying UTF-8 encoding *besides* those already escaped, leaving the URI intact.
    """
    ...

def to_high_limit_path(path):
    ...

def format_field(obj, field=..., template=..., ignore=..., default=..., func=...): # -> str:
    ...

def clean_podcast_url(url): # -> str:
    ...

_HEX_TABLE = ...
def random_uuidv4(): # -> str:
    ...

def make_dir(path, to_screen=...): # -> bool:
    ...

def get_executable_path(): # -> str:
    ...

def load_plugins(name, suffix, namespace): # -> dict[Unknown, Unknown]:
    ...

def traverse_obj(obj, *paths, default=..., expected_type=..., get_all=..., casesense=..., is_user_input=..., traverse_string=...): # -> list[Unknown] | object | None:
    """
    Safely traverse nested `dict`s and `Sequence`s

    >>> obj = [{}, {"key": "value"}]
    >>> traverse_obj(obj, (1, "key"))
    "value"

    Each of the provided `paths` is tested and the first producing a valid result will be returned.
    The next path will also be tested if the path branched but no results could be found.
    Supported values for traversal are `Mapping`, `Sequence` and `re.Match`.
    A value of None is treated as the absence of a value.

    The paths will be wrapped in `variadic`, so that `'key'` is conveniently the same as `('key', )`.

    The keys in the path can be one of:
        - `None`:           Return the current object.
        - `str`/`int`:      Return `obj[key]`. For `re.Match, return `obj.group(key)`.
        - `slice`:          Branch out and return all values in `obj[key]`.
        - `Ellipsis`:       Branch out and return a list of all values.
        - `tuple`/`list`:   Branch out and return a list of all matching values.
                            Read as: `[traverse_obj(obj, branch) for branch in branches]`.
        - `function`:       Branch out and return values filtered by the function.
                            Read as: `[value for key, value in obj if function(key, value)]`.
                            For `Sequence`s, `key` is the index of the value.
        - `dict`            Transform the current object and return a matching dict.
                            Read as: `{key: traverse_obj(obj, path) for key, path in dct.items()}`.

        `tuple`, `list`, and `dict` all support nested paths and branches.

    @params paths           Paths which to traverse by.
    @param default          Value to return if the paths do not match.
    @param expected_type    If a `type`, only accept final values of this type.
                            If any other callable, try to call the function on each result.
    @param get_all          If `False`, return the first matching result, otherwise all matching ones.
    @param casesense        If `False`, consider string dictionary keys as case insensitive.

    The following are only meant to be used by YoutubeDL.prepare_outtmpl and are not part of the API

    @param is_user_input    Whether the keys are generated from user input.
                            If `True` strings get converted to `int`/`slice` if needed.
    @param traverse_string  Whether to traverse into objects as strings.
                            If `True`, any non-compatible object will first be
                            converted into a string and then traversed into.


    @returns                The result of the object traversal.
                            If successful, `get_all=True`, and the path branches at least once,
                            then a list of results is returned instead.
                            A list is always returned if the last path branches and no `default` is given.
    """
    ...

def traverse_dict(dictn, keys, casesense=...): # -> list[Unknown] | object | None:
    ...

def get_first(obj, keys, **kwargs): # -> list[Unknown] | object | None:
    ...

def time_seconds(**kwargs): # -> float:
    ...

def jwt_encode_hs256(payload_data, key, headers=...): # -> bytes:
    ...

def jwt_decode_hs256(jwt): # -> Any:
    ...

WINDOWS_VT_MODE = ...
@functools.cache
def supports_terminal_sequences(stream): # -> Literal[False]:
    ...

def windows_enable_vt_mode(): # -> None:
    ...

_terminal_sequences_re = ...
def remove_terminal_sequences(string): # -> str:
    ...

def number_of_digits(number): # -> int:
    ...

def join_nonempty(*values, delim=..., from_dict=...): # -> str:
    ...

def scale_thumbnails_to_max_format_width(formats, thumbnails, url_width_re): # -> list[dict[Unknown, Unknown]]:
    """
    Find the largest format dimensions in terms of video width and, for each thumbnail:
    * Modify the URL: Match the width with the provided regex and replace with the former width
    * Update dimensions

    This function is useful with video services that scale the provided thumbnails on demand
    """
    ...

def parse_http_range(range): # -> tuple[None, None, None] | tuple[int, int | None, int | None]:
    """ Parse value of "Range" or "Content-Range" HTTP header into tuple. """
    ...

def read_stdin(what): # -> TextIO:
    ...

def determine_file_encoding(data): # -> tuple[Literal['utf-8', 'utf-32-be', 'utf-32-le', 'utf-16-le', 'utf-16-be'], int] | tuple[str | Any | None, Literal[0]]:
    """
    Detect the text encoding used
    @returns (encoding, bytes to skip)
    """
    ...

class Config:
    own_args = ...
    parsed_args = ...
    filename = ...
    __initialized = ...
    def __init__(self, parser, label=...) -> None:
        ...
    
    def init(self, args=..., filename=...): # -> bool:
        ...
    
    def load_configs(self): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    @staticmethod
    def read_file(filename, default=...): # -> list[str]:
        ...
    
    @staticmethod
    def hide_login_info(opts): # -> list[str | Any | Unknown]:
        ...
    
    def append_config(self, *args, label=...): # -> None:
        ...
    
    @property
    def all_args(self): # -> Generator[Unknown | Any, None, None]:
        ...
    
    def parse_known_args(self, **kwargs):
        ...
    
    def parse_args(self):
        ...
    


class WebSocketsWrapper:
    """Wraps websockets module to use in non-async scopes"""
    pool = ...
    def __init__(self, url, headers=..., connect=...) -> None:
        ...
    
    def __enter__(self): # -> Self@WebSocketsWrapper:
        ...
    
    def send(self, *args): # -> None:
        ...
    
    def recv(self, *args): # -> Any:
        ...
    
    def __exit__(self, type, value, traceback): # -> Any:
        ...
    
    @staticmethod
    def run_with_loop(main, loop):
        ...
    


def merge_headers(*dicts): # -> dict[Any, Any]:
    """Merge dicts of http headers case insensitively, prioritizing the latter ones"""
    ...

def cached_method(f): # -> (self: Unknown, *args: Unknown, **kwargs: Unknown) -> Any:
    """Cache a method"""
    ...

class classproperty:
    """property access for class methods"""
    def __init__(self, func) -> None:
        ...
    
    def __get__(self, _, cls):
        ...
    


class Namespace(types.SimpleNamespace):
    """Immutable namespace"""
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    @property
    def items_(self): # -> dict_items[str, Any]:
        ...
    


MEDIA_EXTENSIONS = ...
KNOWN_EXTENSIONS = ...
class RetryManager:
    """Usage:
        for retry in RetryManager(...):
            try:
                ...
            except SomeException as err:
                retry.error = err
                continue
    """
    def __init__(self, _retries, _error_callback, **kwargs) -> None:
        ...
    
    @property
    def error(self): # -> None:
        ...
    
    @error.setter
    def error(self, value): # -> None:
        ...
    
    def __iter__(self): # -> Generator[Self@RetryManager, None, None]:
        ...
    
    @staticmethod
    def report_retry(e, count, retries, *, sleep_func, info, warn, error=..., suffix=...): # -> None:
        """Utility function for reporting retries"""
        ...
    


def make_archive_id(ie, video_id): # -> str:
    ...

def truncate_string(s, left, right=...): # -> str:
    ...

def orderedSet_from_options(options, alias_dict, *, use_regex=..., start=...): # -> Generator[Any | Unknown, None, None] | list[Unknown]:
    ...

has_certifi = ...
has_websockets = ...
